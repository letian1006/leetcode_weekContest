"""
第380场周赛
链接:https://leetcode.cn/contest/weekly-contest-380/
3题选手 t3没有做出来
题目是二分加上位运算的拆位
"""


class Solution:
    """
    给你一个整数 k 和一个整数 x 。
    令 s 为整数 num 的下标从 1 开始的二进制表示。我们说一个整数 num 的 价值 是满足 i % x == 0 且 s[i] 是 设置位 的 i 的数目。
    请你返回 最大 整数 num ，满足从 1 到 num 的所有整数的 价值 和小于等于 k 。
    注意：
    一个整数二进制表示下 设置位 是值为 1 的数位。
    一个整数的二进制表示下标从右到左编号，比方说如果 s == 11100 ，那么 s[4] == 1 且 s[2] == 0 。
    示例：
    输入：k = 9, x = 1
    输出：6
    解释：数字 1 ，2 ，3 ，4 ，5 和 6 二进制表示分别为 "1" ，"10" ，"11" ，"100" ，"101" 和 "110" 。
    由于 x 等于 1 ，每个数字的价值分别为所有设置位的数目。
    这些数字的所有设置位数目总数是 9 ，所以前 6 个数字的价值和为 9 。
    所以答案为 6 。
    """

    def findMaximumNumber(self, k: int, x: int) -> int:

        def check(num):
            # 统计每个有效的比特位的数量
            # 假设x == 3 此时的num为 0b10110001
            # 我们只要第三位 第六位 等位置上的有效比特个数 这个check函数就是确定这些比特个数
            # 是不是小于等于k
            # 比如判断第三位上的有效比特个数 首先num右移动两位 这个数字有多少个奇数 后三位的变化总共有2^3种
            # 有多少个奇数小于一个数字 我们的公式是(num + 1) // 2 也就是右移之后的数字可以造成多少个末尾是奇数的数字个数
            # 再乘上后面比特位的变化个数 得到第一部分的结果 也就是((((num) >> shift) - 1) + 1) / 2 * (2 << m)
            # 前面减1的目的是最后一个数字我们要单独算 比如110 第二个比特位有多少个有效呢
            # 右移一位得到11 那么我们要算的是[0, 3]之间有多少个奇数 也就是(3 + 1)//2个 再乘上2^1 这样你算出来就是4个
            # 这对于最大数字6也就是110 是不对的 因为001 010 011 100 101 110第二位有效的数字只有3个
            # 所以我们只算右移动得到的数字11 减去1 也就是10 能带来的有效比特位数
            # 第二部分是最后一个数字造成的有效比特位数 也就是11能带来的贡献 这个我们使用mask得到 也就是(num & mask)+ 1 (+1是因为包括0)
            # 这样我们就得到了小于num的数字 第三位上的有效比特位数之和是多少
            shift = x - 1
            n = num >> shift
            res = 0
            while n:
                res += (n // 2) << shift
                if n % 2:
                    mask = (1 << shift) - 1
                    res += (num & mask) + 1
                n >>= x
                shift += x
            return res <= k

        l, r = 0, (k + 1) << x
        ans = -1
        while l <= r:
            mid = (l + r) >> 1
            if check(mid):
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans
