"""
2024-2-17 的周赛
给出t3的动态规划代码 和解释过程
"""
from typing import List


class Solution:
    """
    链接:https://leetcode.cn/problems/maximize-consecutive-elements-in-an-array-after-modification/description/

    描述:
    给你一个下标从 0 开始只包含 正 整数的数组 nums 。
    一开始，你可以将数组中 任意数量 元素增加 至多 1 。
    修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。
    请你返回 最多 可以选出的元素数目。

    示例:
    输入：nums = [2,1,5,1,1]
    输出：3
    解释：我们将下标 0 和 3 处的元素增加 1 ，得到结果数组 nums = [3,1,5,2,1] 。
    我们选择元素 [3,1,5,2,1] 并将它们排序得到 [1,2,3] ，是连续元素。
    最多可以得到 3 个连续元素。
    """

    def maxSelectedElements(self, nums: List[int]) -> int:
        # 先排序 然后定义状态为当前数字加1 或者当前数字为结尾的最长连续元素的长度
        # dp0 表示当前数字为结尾的最长连续长度 dp1表示当前数字加1为结尾的最长连续长度
        # 因为我们只能让元素加1 那么最后的连续长度的数组最后一个数字要么是数组中原本就有的数字
        # 要么就是数组中原本就有的数字加1 因此我们这样定义动态规划的状态
        nums.sort()
        ans = 1
        dp0 = dp1 = 1  # 代表以nums[0], nums[0] + 1结尾的最长连续元素的长度
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                # 之前的元素和现在元素相等
                # 所以dp0还是上一个元素计算的dp0 dp1就可以有两种情况
                # 要么是上一个数字的dp1 要么是上一个数字的dp0加1
                # 两者都可以实现一个最后一个连续数字为当前数字加1的效果
                dp0, dp1 = dp0, max(dp1, dp0 + 1)
            elif nums[i] == nums[i - 1] + 1:
                # 之前的元素比现在元素小1
                # 所以要以当前数字为结尾的话 要么用上一个数字的dp0加上1 要么用上一个数字加1
                dp0, dp1 = max(dp1, dp0 + 1), dp1 + 1
            elif nums[i] == nums[i - 1] + 2:
                dp0, dp1 = dp1 + 1, 1
            else:
                # 如果相差大于2 那么当前数字为结尾或者当前数字加1为结尾的
                # 长度只能是1 因为之前的数字都不可能和当前数字相连 无论是加1还是不加1
                dp0, dp1 = 1, 1
            ans = max(ans, dp0, dp1)
        return ans
